# -*- coding: utf-8 -*-
"""qml_rain_or_not.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Vco4whlkHoxDgHWcMsN4VsLPwZkIvm6r
"""

#importing dependencies
import pennylane as qml
from pennylane import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score
import matplotlib.pyplot as plt

#reading in the dataset
df = pd.read_csv("4129666.csv")

df.head()

#Selecting features and label

features = ["TMAX", "TMIN", "PRCP"]
X = df[features].values
y = (df["PRCP"].values > 0).astype(int)

#Scaling predicting variables
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.25, random_state=42)

n_qubits = X_train.shape[1]
dev = qml.device("default.qubit", wires=n_qubits)

n_layers = 3
params = np.random.randn(n_layers, n_qubits, 3, requires_grad=True)

def cost(params, X, y):
    preds = [qnode(params, x) for x in X]
    preds = [(p+1)/2 for p in preds]  # Map [-1,1] → [0,1]
    return np.mean((preds - y)**2)

opt = qml.GradientDescentOptimizer(stepsize=0.1)
epochs = 100

n_qubits = X_train.shape[1]
dev = qml.device("default.qubit", wires=n_qubits)

@qml.qnode(dev)
def qnode(params, x):
    for i in range(len(params)):
        # Data re-uploading
        for w in range(n_qubits):
            qml.RX(x[w], wires=w)
        # Variational layer
        for w in range(n_qubits):
            qml.Rot(params[i,w,0], params[i,w,1], params[i,w,2], wires=w)
        # Entanglement (ring)
        for w in range(n_qubits):
            qml.CNOT(wires=[w, (w+1)%n_qubits])
    return qml.expval(qml.PauliZ(0))

def cost(params, X, y):

    preds = np.array([qnode(params, x) for x in X])
    preds = (preds + 1)/2  # Map from [-1,1] → [0,1]
    return np.mean((preds - y)**2)  # works with ArrayBox

opt = qml.GradientDescentOptimizer(stepsize=0.1)
epochs = 100

# Training loop
for epoch in range(epochs):
    params = opt.step(lambda v: cost(v, X_train, y_train), params)
    if (epoch+1) % 20 == 0:
        loss = cost(params, X_train, y_train)
        print(f"Epoch {epoch+1}, Loss = {loss:.4f}")

# Evaluate predictions as numeric values
preds_test = np.array([qnode(params, x) for x in X_test])
preds_test = (preds_test + 1)/2  # Map [-1,1] → [0,1]
preds_test = preds_test > 0.5    # Convert to boolean labels
accuracy = accuracy_score(y_test, preds_test)
print(f"Test Accuracy: {accuracy*100:.2f}%")

import matplotlib.pyplot as plt

# Use two features for 2D plot, e.g., TMAX vs PRCP
feature_x = X_test[:, 0]  # TMAX
feature_y = X_test[:, 2]  # PRCP

plt.figure(figsize=(8,6))
plt.scatter(feature_x, feature_y, c=preds_labels, cmap='coolwarm', marker='o', edgecolor='k', alpha=0.7)
plt.xlabel("TMAX (scaled)")
plt.ylabel("PRCP (scaled)")
plt.title("QRU Rain Predictions (0=No Rain, 1=Rain)")
plt.colorbar(label="Predicted Label")
plt.show()



